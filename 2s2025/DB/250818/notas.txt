  Aula 2, iniciada de acordo com os slides fornecidos pela professora no teams.
  vimos como iniciar o comando utilizando o compass, e abrir o shel pelo compass, executando comandos iniciais

	use <nome db>
	db.createCollection <nome da coleção de dados>
	db.<nome da coleçao>.insertOne(<dados no formato json>) - db.teste.insertOne({nome:"Marcos",idade:"32"})
	
	assim como demonstrado os comando iniciais, para criação do banco, criação da coleção de dados e inserção dos dados, os proximos serão respectivamente para atualizar, e deletar dados unitarios

	db.teste.updateOne(<referencia>,<alteração>) - db.teste.updateOne({nome:"Marcos"},{$set:{idade:"30"})
	db.teste.deleteOne(<referencia>) - db.teste.deleteOne({nome:"Marcos"})

 Seguindo assim um mesmo padrão de comandos do banco de dados relacional, porem com propria grafia, e como os dados nao ficam salvos em tabela, podemos desenvolver as coleções por conjunto de dados para uso, formato dos dados, ou por integrantes de dados no sistema.
	geralmente usa-se as coleções como se usa as tabelas no banco de dados relacional, por exemplo, utilizando coleções como Vendas, ou usuarios e assim por diante para organizar os documentos json usando como referencia suas utilidades, ou seus usos no sistema
	
  Durante a aula, realizamos a atividade pratica do pdf Aula2, sem muito a ser verificado, adicionando os comando embedding e referencing.

  embedding trata-se de utilizar um documento jason, com um outro documento json dentro dele,

  	ex:
		vamos criar uma nova coleção
		db.createCollection("Venda")
		vamos entao criar o dado em formato embedding
		db.ClienteVenda.insertOne({nome:"Carlos",
					pedidos:[
					{produto:"notebook", valor:3500},
					{produto:"mouse", valor:50}
					]
					})
			desta forma o conteudo do pedido esta salvo no mesmo documento(conjunto de dados json) que o cliente e assim por diante.
		assim recuperamos os dados com algo como
		db.vendas.find() - relacionando todos os registros ou
		db.vendas.find({nome:"Carlos"}) - relacionando os produtos do clinete carlos

		já para o formato referencing começamos criando as duas duas coleçoes separadas, uma para clientes e outra para pedidos
		db.createCollection("clientes")
		db.createCollection("pedidos")
		depois inserimos em cada uma das coleções os dados referenciando ambos depois(na hora da pesquisa)
		db.clientes.insertOne({_id:1, nome:"Marcos"});
		db.pedidos.insertOne({usuario_id:1, produto:"notebook", valor:3500});
		posteriormente para recuperar os dados usasse o operador aggregate
		db.clientes.aggregate([
			{
			$lookup:{
				from:"pedidos",
				localfield:"_id",
				foreingfield:"usuario_id",
				as "pedidos_do_usuario"
				}
			}
		])
		assim, como esta, ele pega todos os dados cadastrados em usuarios, exibindo deus dados agregados manualmente
		para exibir unitariamente adiciona-se o referencial $match para buscar apenas um dos resultados
		db.clientes.aggregate([
			{
			$lookup:{
				from:"pedidos",
				localField:"_id",	- referencia dentro da coleção clientes
				foreignField:"usuario_id",	- referencia dentro da coleção pedidos
				as: "pedidos_do_usuario"
				}
			},
			{
			$match:{-id:2} 		- define o referencia de pesquisa par o id 2
			}
		])

